# If you have a non-empty list "a", you can unpack it with "a \x xs. expr".
# Let's use this to unpack our whole data section into (nl:cB:cF:ci:cu:zd), where zd is ('z':digits).
(\I. I \nl I. I \cB I. I \cF I. I \ci I. I \cu zd.
  # Some useful functions:
  cons = \x y z.z x y
  true = \x y.x
  nil = \x y.y
  Y = \f.(\x.x x)(\x.f (x x))
  foldr = \f z.Y(\self a.a (\l r z.f l (self r)) z)
  flip_app = foldr cons
  app = \a b.flip_app b a
  map = \f.foldr(\l r.cons (f l)r)nil

  # Create the list r1_100 = ["1","2",...,"99",???] via a Cartesian product.
  # We will overwrite the final element with "Buzz", so it doesn't matter what it is.
  # (cons nil nil) would be proper. __3 (variable 1110) magically seems to work and save a byte.
  d = zd nil
  concatMap = \f.foldr (\a b. flip_app b (f a)) nil
  fd = map cons d
  fd1 = cons (\a.a) (fd nil)
  r0_99 = concatMap (\x. map (\y. x (y nil)) fd) fd1
  r1_100 = app (r0_99 nil) __3

  # Create "Fizz" and "Buzz" strings.
  cz = zd true
  zz = cons cz (cons cz nil)
  Fizz = cons cF (cons ci zz)
  Buzz = cons cB (cons cu zz)

  # Some higher-order functions:
  #   m1   f c (x:xs) = f x : c xs
  #   p1 m f c (x:xs) = x : m f c xs
  #
  # These combine into the functions:
  #   m3 f c (v:w:x:xs) = v : w : f x : c xs
  #   m5 f c (t:u:v:w:x:xs) = t : u : v : w : f x : c xs
  #
  # and then e3=Y(m3 f) will apply f to every 3rd element of a stream.
  # It doesn't handle nil nicely, but it's ok to crash after line 100.
  p1 = \m f c a. a \x xs. cons x (m f c xs)
  m1 = \f c a.a \x xs. cons (f x) (c xs)
  m3 = p1 (p1 m1)
  m5 = p1 (p1 m3)
  e3 = \f.Y(m3 f)
  e5 = \f.Y(m5 f)
  unlines = foldr (\l r. app l (cons nl r)) nil
  unlines (e5 (flip_app Buzz)
          (e3 (\k.Fizz)
          (e5 (\k.nil) r1_100)))
) "\nBFiuz0123456789